# Vulnerability recurrence 

### The first loophole to reproduce is  CVE-2020-1021 

The code is based on an excellent vulnerability report  https://github.com/guhe120/Windows-EoP/blob/master/CVE-2020-1021/writeup.docx 

This code is only capable of triggering vulnerabilities wersvc!CWerService::SvcCollectMemoryInfo

My experimental environment is 1903 x64

I want to record something：

If the MaxMessageLength field in the fourth parameter ALPC_PORT_ATTRIBUTES of NtAlpcConnectPort is not set, then the length of the message sent by NtAlpcSendWaitReceivePort cannot exceed 0x200, and a 0xC000002F will be returned

If the sending length exceeds the maximum length specified by the server (NtAlpcSendWaitReceivePort is the third parameter from the bottom), you will get a 0xC0000707 

CreateFile will not be affected by disk storage space. WriteFile will 

### The second recurring vulnerability is CVE-2020-1515 

My experimental environment is 1903 x64

This is an integer overflow vulnerability in tapisrv.dll. From the perspective of the patch, the functions that have been patched include PInitialize, LInitialize, GetUIDllName and other functions, and the causes of the vulnerability are all integers, overflow，This vulnerability is an out-of-bounds heap write caused by an integer overflow. 

One big limitation is that in order to trigger an overflow, the server needs to have enough memory, otherwise it will return rpc error 14 

To call these functions, you need to connect to the tapisrv.dll server as an rpc client, and then you need to call ClientAttach to get a context_handle, and then call ClientAttach. ClientAttach will choose which function to call according to the value of parameter three

This code calls PInitialize, bypasses IsBadStringParam, but is only close to overflow 

1: kd>   
tapisrv!PInitialize+0xa3:  
0033:00007ffe 39672a63 4503c7 add r8d,r15d  
1: kd>   
tapisrv!PInitialize+0xa6:   
0033:00007ffe 39672a66 ff15dc980100 call qword ptr [tapisrv!_imp_HeapAlloc (00007ffe 3968c348)]   
1: kd> r r8   
r8=00000000ffffff6c    

I want to record something： 

By default, the rpc server will have the parameter to check [in], but not [out], because the server will not accept the value with the [out] parameter, but only accepts a format like this

rpc view will not decompile whether idl is an implicit handle or a display handle, you need to try it yourself 

### The third recurring vulnerability is CVE-2020-17012 

My experimental environment is 1903 x64

To start the bindflt.sys, refer to http://revertservice.com/10/bindflt

From the perspective of the patch, Microsoft directly does not allow ordinary users to call the IOCTL dispatch function BfDrvDeviceControl

The cause of the vulnerability is that BfDrvDeviceControl did not verify the value in the input buffer, and then called directly
RtlInitUnicodeString refers to the value in the buffer caused 

nt!RtlInitUnicodeString + 0x23:
fffff8035843df53 66833c4200      cmp     word ptr[rdx + rax * 2], 0 ds:002b : 4141414141414141= ? ? ? ?
Resetting default scope
 
It is easier to dig out vulnerabilities and find places that are less known. 

It's a pity that I haven't thought about analyzing such a driver that is not self-starting. 

### The fourth loophole reproduced is CVE-2020-16892

My experimental environment is 1903 x64

The fourth recurring vulnerability is CVE-2020-16892 

The vulnerable file is wiaservc.dll. From the patch, there are a lot of bugs, which are basically caused by not locking the COM interface functions.

To view these interfaces, you can use OleViewDotNet

I chose to use CEnumWiaItem::~CEnumWiaItem, I can compete for UAF

Instantiating an IEnumWiaItem requires some methods to construct, I refer to here

https://docs.microsoft.com/en-us/windows/win32/api/wia_xp/nf-wia_xp-ienumwiaitem-reset

https://docs.microsoft.com/zh-cn/windows/win32/wia/-wia-wia-tutorial

There is a big limitation in the place I choose to use: if there is no WIA device then IEnumWiaItem cannot be instantiated 


